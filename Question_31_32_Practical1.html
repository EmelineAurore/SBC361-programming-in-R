<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<p>What follow are some ideas of how to answer those last few questions the first practical session. Remember that there are dozens of manners of answering a question, and no single one is best. We provide a few possibilities for each. Other ideas that we may not have listed are perfectly valid as well!</p>
<p>As a general rule, it can be better to be more specific, but in a real life situation you would want to include some sort of automated verification that your code is performing as you intend (in particular when you move on to larger datasets for which it is hard to have an overview).</p>
<p>Ok, ok, now let's get hacking.</p>
<h2 id="q31.-add-three-additional-columns-to-the-reptile_data-table">Q31. Add three additional columns to the reptile_data table:</h2>
<p>First let's create one vector for each; we can worry about combining them into the <code>reptile_data</code> table later.</p>
<h3 id="one-containing-only-the-identifier-numbers-e.g.-1423-without-the-id">One containing only the identifier numbers (e.g. 1423 without the “ID”)</h3>
<h4 id="it-might-be-easiest-to-do-this-in-two-steps.-for-example">It might be easiest to do this in two steps. For example:</h4>
<pre><code>id_numbers_temp &lt;- gsub(x = reptile_names,   replacement = &quot;&quot;, pattern = &quot;ID&quot;)
id_numbers      &lt;- gsub(x = id_numbers_temp, replacement = &quot;&quot;, pattern = &quot;:.+&quot;)
rm(id_numbers_temp)</code></pre>
<p>This can be a bit risky though. For example, what happens if the species name contains &quot;ID&quot;, or if there are multiple &quot;:&quot;? Thus it is better to be more specific. You will be more in control of what the computer is doing, and thus it is less likely to do something you didn't intend. The following example is more specific than the previous: <code>id_numbers_temp &lt;- gsub(x = reptile_names,   replacement = &quot;&quot;, pattern = &quot;^ID&quot;) id_numbers      &lt;- gsub(x = id_numbers_temp, replacement = &quot;&quot;, pattern = &quot;:[A-z ]+$&quot;) rm(id_numbers_temp)</code></p>
<p>If we wanted our regexp to be more general (e.g. if we know that &quot;ID&quot; might be in other cases be other capitalized letters, and if some species may be unresolved and thus be abbreviated as &quot;sp.&quot;), we could for example do the following: <code>id_numbers_temp &lt;- gsub(x = reptile_names,   replacement = &quot;&quot;, pattern = &quot;^[A-Z]+&quot;) id_numbers      &lt;- gsub(x = id_numbers_temp, replacement = &quot;&quot;, pattern = &quot;:[A-z \\.]+$&quot;) rm(id_numbers_temp)</code></p>
<h4 id="or-we-can-combine-those-two-into-a-single-line">Or we can combine those two into a single line:</h4>
<p><code>gsub</code> can &quot;find&quot; a regular expression match multiple times. So we can combine two parts with a <code>|</code>, taking care to use parentheses appropriately. Here are some examples of combinations:</p>
<p>Risky but works: <code>id_numbers &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;([A-Z]+)|(:.+)&quot;)</code></p>
<p>Less risky because more specific while keeping some generality: <code>id_numbers &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;(^[A-z]+)|(:[A-z \\.]+$)&quot;)</code></p>
<p>Specific for this dataset: <code>id_numbers &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;(^ID)|(:[A-z ]+$)&quot;)</code></p>
<h4 id="or-we-take-a-minimalistic-approach-by-exclusion-of-everything-that-is-not-a-number">Or we take a minimalistic approach by exclusion of everything that is not a number</h4>
<pre><code>id_numbers &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;[^0-9]&quot;)</code></pre>
<h3 id="one-column-containing-only-the-genus-e.g.-bellatorias">One column containing only the genus (e.g. Bellatorias):</h3>
<p>Risky but works: <code>only_genus_temp &lt;- gsub(x = reptile_names,   replacement = &quot;&quot;, pattern = &quot;(.+:)&quot;) only_genus      &lt;- gsub(x = only_genus_temp, replacement = &quot;&quot;, pattern = &quot;( .+)&quot;) rm(only_genus_temp)</code></p>
<p>More specific, less risky: <code>only_genus_temp &lt;- gsub(x = reptile_names,   replacement = &quot;&quot;, pattern = &quot;([A-z]+[0-9]+:)&quot;) only_genus      &lt;- gsub(x = only_genus_temp, replacement = &quot;&quot;, pattern = &quot;( [A-z]+)&quot;) rm(only_genus_temp)</code></p>
<h4 id="we-can-also-combine-those-two-options-above-each-one-into-one-single-line">We can also combine those two options above, each one into one single line:</h4>
<p>Risky: <code>only_genus &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;(.+:)|( .+)&quot;)</code></p>
<p>Less risky: <code>only_genus &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;([A-z]+[0-9]+:)|( [A-z]+)&quot;)</code></p>
<h3 id="one-column-containing-only-the-species-excluding-the-subspecies-e.g.-tympanum">One column containing only the species (excluding the subspecies, e.g. tympanum):</h3>
<h4 id="as-mentioned-above-it-is-easier-to-do-it-in-two-steps">As mentioned above, it is easier to do it in two steps:</h4>
<p>Risky: <code>R only_species_temp &lt;- gsub(x = reptile_names,     replacement = &quot;&quot;, pattern = &quot;(.+:)&quot;) only_species      &lt;- gsub(x = only_species_temp, replacement = &quot;&quot;, pattern = &quot;(^[A-z]+ )|( .+$)&quot;) rm(only_species_temp)</code></p>
<p>We can be more specific, making our script more readable, thus less risky: <code>R only_species_temp &lt;- gsub(x = reptile_names,     replacement = &quot;&quot;, pattern = &quot;([A-z]+[0-9]+:)&quot;) only_species      &lt;- gsub(x = only_species_temp, replacement = &quot;&quot;, pattern = &quot;(^[A-z]+ )|( [A-z]+$)&quot;) rm(only_species_temp)</code></p>
<h4 id="we-can-also-combine-the-above-scripts-into-one-single-line-each">We can also combine the above scripts into one single line each:</h4>
<p>Risky: <code>R only_species &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;(.+:)([A-z]+ )|( .+$)&quot;)</code> Less risky: <code>R only_species &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;(^[A-z]+[0-9]+:)([A-z]+ )|( [A-z]+$)&quot;)</code></p>
<h4 id="now-you-can-add-the-columns-to-the-reptile_data-data-frame">Now you can add the columns to the reptile_data data frame:</h4>
<p>We can use <code>cbind</code> for this: <code>R reptile_data_q31 &lt;- cbind(reptile_data, id_numbers, only_genus, only_species)</code></p>
<p>Or we can use the <code>$</code>. For example, <code>reptile_data$V4</code> would pull out the year. If we try to access <code>reptile_data$id_nums</code>, that doesn't exist. But we can create it: <code>R reptile_data$id_nums &lt;- id_numbers</code></p>
<p>And so on for the others. Or we can use the <code>[]</code> square brackets. I find this more risky because it's hard to remember whether rows or columns come first. Anyhow here is one way with a named column: <code>R reptile_data[,'id_nums'] &lt;- id_numbers</code></p>
<p>And another way (even more risky), just using the column number. I dislike this approach because it's easy to accidentally overwrite an existing column. <code>R reptile_data[,5] &lt;- id_numbers</code></p>
<p>Obviously, you could also combine the data modification and merging into the table into a single step creation multiple steps. For example: <code>R reptile_data$id_nums &lt;- gsub(x = reptile_names, pattern = &quot;[^0-9]&quot;, replacement = &quot;&quot;)</code></p>
<p>Or: <code>R reptile_data_q31 &lt;- cbind(               reptile_data,                id      = gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;[^0-9]&quot;),                genus   = gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;(^[A-z]+[0-9]+:)|( [A-z]+$)&quot;),               species = gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;(^[A-z]+[0-9]+:)([A-z]+ )|( [A-z]+$)&quot;)               )</code></p>
<h2 id="hacker-q32.-figure-out-how-to-capture-the-first-letter-of-the-species-and-transform-it-to-make-it-uppercase.">Hacker Q32. Figure out how to “capture” the first letter of the species, and transform it to make it uppercase.</h2>
<p>Do this in a generic manner (that would work on a table of thousands of species).</p>
<h3 id="easiest-way-using-captures">Easiest way using captures</h3>
<p>Here we're decomposing.</p>
<pre class="sourceCode R"><code class="sourceCode r"><span class="co"># we write the regex only once to reduce risks</span>
multi_part_regex       &lt;- <span class="st">&quot;^([A-z]+[0-9]+:[A-z]+ )(.)([a-z ]+$)&quot;</span>

<span class="co"># now lets replace the whole string by just the first group to delete the rest</span>
<span class="co"># store the result in a variable. Then repeat for other two parenthesis groups</span>
first_part             &lt;- <span class="kw">gsub</span>(<span class="dt">x =</span> reptile_names, <span class="dt">replacement =</span> <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1&quot;</span>, <span class="dt">pattern =</span> multi_part_regex)
species_first_char     &lt;- <span class="kw">gsub</span>(<span class="dt">x =</span> reptile_names, <span class="dt">replacement =</span> <span class="st">&quot;</span><span class="ch">\\</span><span class="st">2&quot;</span>, <span class="dt">pattern =</span> multi_part_regex)
last_part              &lt;- <span class="kw">gsub</span>(<span class="dt">x =</span> reptile_names, <span class="dt">replacement =</span> <span class="st">&quot;</span><span class="ch">\\</span><span class="st">3&quot;</span>, <span class="dt">pattern =</span> multi_part_regex)

<span class="co">#google &quot;uppercase in R&quot; finds the toupper function!</span>
species_first_char_big &lt;- <span class="kw">toupper</span>(species_first_char)

reptile_names_q32      &lt;- <span class="kw">paste</span>(first_part, species_first_char_big, last_part, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)</code></pre>
<h3 id="alternative-way-without-captures">Alternative way without captures</h3>
<pre><code>first_part  &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot; .+&quot;)
species     &lt;- gsub(x = reptile_names, replacement = &quot;&quot;, pattern = &quot;[A-z]+[0-9]+:[A-z]+ &quot;)

#google &quot;extract part of string in R&quot; finds the substr function
species_first_char     &lt;- substr(x=species, start=0, stop=1)
species_first_char_big &lt;- toupper(species_first_char)

species_rest &lt;- gsub(x = species, pattern = &quot;^.&quot;, replacement = &quot;&quot;)
reptile_names_q32      &lt;- paste(first_part, species_first_char_big, species_rest, sep = &quot;&quot;)</code></pre>
<h3 id="with-captures-and-perl-extensions-both-in-one-single-line-each">With captures and perl extensions, both in one single line each:</h3>
<pre><code>reptile_names_q32 &lt;- gsub(x           = reptile_names,
                          pattern     = &quot;(^ID[0-9]+:[A-z]+ )([A-z])([a-z ]+$)&quot;,
                          replacement = &quot;\\1\\U\\2\\L\\3&quot;,
                          perl        = TRUE)</code></pre>
<p>The <code>replacement</code> in the <code>gsub()</code> above means: keep the first group (groups are sets of parentheses in the 'pattern'; in the same order) then keep the space, captalize the second group, and put the third group in lowercase.</p>
<p>A less specific approach:</p>
<pre><code>reptile_names_q32 &lt;- gsub(x           = reptile_names, 
                          pattern     = &quot;(^[A-z:0-9]+ )(.)(.+)$&quot;, 
                          replacement = &quot;\\1\\U\\2\\L\\3&quot;, 
                          perl        = TRUE)</code></pre>
</body>
</html>
